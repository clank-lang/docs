// Form Validation Pattern
// Demonstrates: refinement types for validation, accumulating errors

// Validated types
Ï„ Username = ğ•Š{
  len(self) â‰¥ 3 âˆ§
  len(self) â‰¤ 20 âˆ§
  all(chars(self), is_alphanumeric)
}

Ï„ Email = ğ•Š{
  len(self) > 0 âˆ§
  contains(self, "@") âˆ§
  contains(self, ".") âˆ§
  len(self) â‰¤ 254
}

Ï„ Password = ğ•Š{
  len(self) â‰¥ 8 âˆ§
  any(chars(self), is_uppercase) âˆ§
  any(chars(self), is_lowercase) âˆ§
  any(chars(self), is_digit)
}

Ï„ Age = â„•{self â‰¥ 13 âˆ§ self â‰¤ 120}

// Validation errors
sum ValidationError {
  TooShort { field: ğ•Š, min: â„•, actual: â„• },
  TooLong { field: ğ•Š, max: â„•, actual: â„• },
  InvalidFormat { field: ğ•Š, reason: ğ•Š },
  MissingRequired { field: ğ•Š },
  OutOfRange { field: ğ•Š, min: â„¤, max: â„¤, actual: â„¤ }
}

// Accumulating validation â€” collect all errors
Ï„ Validated[T] = Result[T, [ValidationError]]

// Smart constructors that return validation results
Æ’ validate_username(s: ğ•Š) â†’ Validated[Username] {
  let mut errors: [ValidationError] = []

  if len(s) < 3 {
    errors = errors ++ [TooShort { field: "username", min: 3, actual: len(s) }]
  }
  if len(s) > 20 {
    errors = errors ++ [TooLong { field: "username", max: 20, actual: len(s) }]
  }
  if Â¬all(chars(s), is_alphanumeric) {
    errors = errors ++ [InvalidFormat { field: "username", reason: "must be alphanumeric" }]
  }

  if is_empty(errors) {
    Ok(unsafe_coerce(s))  // Safe: we validated the constraints
  } else {
    Err(errors)
  }
}

Æ’ validate_email(s: ğ•Š) â†’ Validated[Email] {
  let mut errors: [ValidationError] = []

  if len(s) == 0 {
    errors = errors ++ [MissingRequired { field: "email" }]
  } else {
    if Â¬contains(s, "@") {
      errors = errors ++ [InvalidFormat { field: "email", reason: "missing @" }]
    }
    if Â¬contains(s, ".") {
      errors = errors ++ [InvalidFormat { field: "email", reason: "missing domain" }]
    }
    if len(s) > 254 {
      errors = errors ++ [TooLong { field: "email", max: 254, actual: len(s) }]
    }
  }

  if is_empty(errors) {
    Ok(unsafe_coerce(s))
  } else {
    Err(errors)
  }
}

Æ’ validate_password(s: ğ•Š) â†’ Validated[Password] {
  let mut errors: [ValidationError] = []

  if len(s) < 8 {
    errors = errors ++ [TooShort { field: "password", min: 8, actual: len(s) }]
  }
  if Â¬any(chars(s), is_uppercase) {
    errors = errors ++ [InvalidFormat { field: "password", reason: "needs uppercase letter" }]
  }
  if Â¬any(chars(s), is_lowercase) {
    errors = errors ++ [InvalidFormat { field: "password", reason: "needs lowercase letter" }]
  }
  if Â¬any(chars(s), is_digit) {
    errors = errors ++ [InvalidFormat { field: "password", reason: "needs digit" }]
  }

  if is_empty(errors) {
    Ok(unsafe_coerce(s))
  } else {
    Err(errors)
  }
}

Æ’ validate_age(n: â„¤) â†’ Validated[Age] {
  if n < 13 âˆ¨ n > 120 {
    Err([OutOfRange { field: "age", min: 13, max: 120, actual: n }])
  } else {
    Ok(unsafe_coerce(n))
  }
}

// Registration form
rec RegistrationInput {
  username: ğ•Š,
  email: ğ•Š,
  password: ğ•Š,
  age: â„¤
}

rec ValidRegistration {
  username: Username,
  email: Email,
  password: Password,
  age: Age
}

// Combine validations, accumulating all errors
Æ’ validate_registration(input: RegistrationInput) â†’ Validated[ValidRegistration] {
  let username_result = validate_username(input.username)
  let email_result = validate_email(input.email)
  let password_result = validate_password(input.password)
  let age_result = validate_age(input.age)

  // Collect all errors
  let all_errors = concat([
    errors_of(username_result),
    errors_of(email_result),
    errors_of(password_result),
    errors_of(age_result)
  ])

  if is_empty(all_errors) {
    // All validations passed
    Ok(ValidRegistration {
      username: unwrap(username_result),
      email: unwrap(email_result),
      password: unwrap(password_result),
      age: unwrap(age_result)
    })
  } else {
    Err(all_errors)
  }
}

Æ’ errors_of[T](result: Validated[T]) â†’ [ValidationError] {
  match result {
    Ok(_) â†’ [],
    Err(errs) â†’ errs
  }
}

// Format errors for display
Æ’ format_errors(errors: [ValidationError]) â†’ ğ•Š {
  errors
    |> map(format_error)
    |> join("\n")
}

Æ’ format_error(e: ValidationError) â†’ ğ•Š {
  match e {
    TooShort { field, min, actual } â†’
      field ++ ": too short (min " ++ str(min) ++ ", got " ++ str(actual) ++ ")",
    TooLong { field, max, actual } â†’
      field ++ ": too long (max " ++ str(max) ++ ", got " ++ str(actual) ++ ")",
    InvalidFormat { field, reason } â†’
      field ++ ": " ++ reason,
    MissingRequired { field } â†’
      field ++ ": required",
    OutOfRange { field, min, max, actual } â†’
      field ++ ": out of range (" ++ str(min) ++ "-" ++ str(max) ++ ", got " ++ str(actual) ++ ")"
  }
}

Æ’ main() â†’ IO[()] {
  let input = RegistrationInput {
    username: "ab",           // Too short
    email: "not-an-email",    // Invalid
    password: "weak",         // Too short, missing uppercase, digit
    age: 10                   // Too young
  }

  match validate_registration(input) {
    Ok(reg) â†’ println("Registration valid: " ++ reg.username),
    Err(errors) â†’ {
      println("Validation failed:")
      println(format_errors(errors))
    }
  }
}
