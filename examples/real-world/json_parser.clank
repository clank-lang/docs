// JSON Data Type and Operations
// Demonstrates: recursive types, pattern matching, real-world data

// JSON value type
sum Json {
  Null,
  Bool(ğ”¹),
  Number(â„),
  String(ğ•Š),
  Array([Json]),
  Object(Map[ğ•Š, Json])
}

// Accessors with type safety
Æ’ as_bool(json: Json) â†’ Option[ğ”¹] {
  match json {
    Bool(b) â†’ Some(b),
    _ â†’ None
  }
}

Æ’ as_number(json: Json) â†’ Option[â„] {
  match json {
    Number(n) â†’ Some(n),
    _ â†’ None
  }
}

Æ’ as_string(json: Json) â†’ Option[ğ•Š] {
  match json {
    String(s) â†’ Some(s),
    _ â†’ None
  }
}

Æ’ as_array(json: Json) â†’ Option[[Json]] {
  match json {
    Array(arr) â†’ Some(arr),
    _ â†’ None
  }
}

Æ’ as_object(json: Json) â†’ Option[Map[ğ•Š, Json]] {
  match json {
    Object(obj) â†’ Some(obj),
    _ â†’ None
  }
}

// Path-based access
Æ’ get(json: Json, key: ğ•Š) â†’ Option[Json] {
  match json {
    Object(obj) â†’ obj.get(key),
    _ â†’ None
  }
}

Æ’ get_index(json: Json, i: â„•) â†’ Option[Json] {
  match json {
    Array(arr) if i < len(arr) â†’ Some(arr[i]),
    _ â†’ None
  }
}

// Chained access: json["user"]["name"]
Æ’ get_path(json: Json, path: [ğ•Š]) â†’ Option[Json] {
  let mut current = json
  for key âˆˆ path {
    match get(current, key) {
      Some(next) â†’ current = next,
      None â†’ return None
    }
  }
  Some(current)
}

// Type-safe getters
Æ’ get_string(json: Json, key: ğ•Š) â†’ Option[ğ•Š] {
  get(json, key) |> flat_map(as_string)
}

Æ’ get_number(json: Json, key: ğ•Š) â†’ Option[â„] {
  get(json, key) |> flat_map(as_number)
}

Æ’ get_bool(json: Json, key: ğ•Š) â†’ Option[ğ”¹] {
  get(json, key) |> flat_map(as_bool)
}

// Pretty printing
Æ’ to_string(json: Json) â†’ ğ•Š {
  to_string_indent(json, 0)
}

Æ’ to_string_indent(json: Json, indent: â„•) â†’ ğ•Š {
  let spaces = repeat(" ", indent)
  let inner_spaces = repeat(" ", indent + 2)

  match json {
    Null â†’ "null",
    Bool(true) â†’ "true",
    Bool(false) â†’ "false",
    Number(n) â†’ str(n),
    String(s) â†’ "\"" ++ escape_string(s) ++ "\"",
    Array([]) â†’ "[]",
    Array(items) â†’ {
      let inner = items
        |> map(Î»j â†’ inner_spaces ++ to_string_indent(j, indent + 2))
        |> join(",\n")
      "[\n" ++ inner ++ "\n" ++ spaces ++ "]"
    },
    Object(obj) if obj.is_empty() â†’ "{}",
    Object(obj) â†’ {
      let inner = obj
        |> entries
        |> map(Î»(k, v) â†’ inner_spaces ++ "\"" ++ k ++ "\": " ++ to_string_indent(v, indent + 2))
        |> join(",\n")
      "{\n" ++ inner ++ "\n" ++ spaces ++ "}"
    }
  }
}

Æ’ escape_string(s: ğ•Š) â†’ ğ•Š {
  s
    |> replace("\\", "\\\\")
    |> replace("\"", "\\\"")
    |> replace("\n", "\\n")
    |> replace("\t", "\\t")
    |> replace("\r", "\\r")
}

// Example: Parse user from JSON
rec User {
  id: â„¤,
  name: ğ•Š,
  email: ğ•Š
}

Æ’ parse_user(json: Json) â†’ Option[User] {
  let id = get_number(json, "id") |> map(to_int)?
  let name = get_string(json, "name")?
  let email = get_string(json, "email")?
  Some(User { id, name, email })
}

Æ’ main() â†’ IO[()] {
  let json = Object(Map::from([
    ("id", Number(123.0)),
    ("name", String("Alice")),
    ("email", String("alice@example.com")),
    ("tags", Array([String("admin"), String("active")]))
  ]))

  println(to_string(json))

  match parse_user(json) {
    Some(user) â†’ println("Parsed user: " ++ user.name),
    None â†’ println("Failed to parse user")
  }
}
