// State Machine Pattern
// Demonstrates: sum types for states, exhaustive transitions

// Order processing state machine
sum OrderState {
  Created,
  PaymentPending,
  PaymentReceived(PaymentInfo),
  Processing,
  Shipped(TrackingInfo),
  Delivered,
  Cancelled(ð•Š)  // reason
}

rec PaymentInfo {
  amount: â„{self > 0.0},
  method: ð•Š,
  transaction_id: ð•Š
}

rec TrackingInfo {
  carrier: ð•Š,
  tracking_number: ð•Š,
  estimated_delivery: Date
}

// Events that can occur
sum OrderEvent {
  SubmitPayment(PaymentInfo),
  PaymentConfirmed,
  StartProcessing,
  Ship(TrackingInfo),
  MarkDelivered,
  Cancel(ð•Š)
}

// State transition function â€” exhaustive pattern matching ensures all cases handled
Æ’ transition(state: OrderState, event: OrderEvent) â†’ Result[OrderState, ð•Š] {
  match (state, event) {
    // Created â†’ PaymentPending
    (Created, SubmitPayment(info)) â†’ Ok(PaymentPending),

    // PaymentPending â†’ PaymentReceived
    (PaymentPending, PaymentConfirmed) â†’ {
      // In real code, payment info would come from event
      Err("PaymentConfirmed needs payment info")
    },

    // PaymentReceived â†’ Processing
    (PaymentReceived(_), StartProcessing) â†’ Ok(Processing),

    // Processing â†’ Shipped
    (Processing, Ship(tracking)) â†’ Ok(Shipped(tracking)),

    // Shipped â†’ Delivered
    (Shipped(_), MarkDelivered) â†’ Ok(Delivered),

    // Cancellation from any cancellable state
    (Created, Cancel(reason)) â†’ Ok(Cancelled(reason)),
    (PaymentPending, Cancel(reason)) â†’ Ok(Cancelled(reason)),
    (PaymentReceived(_), Cancel(reason)) â†’ Ok(Cancelled(reason)),

    // Cannot cancel after processing started
    (Processing, Cancel(_)) â†’ Err("Cannot cancel order in processing"),
    (Shipped(_), Cancel(_)) â†’ Err("Cannot cancel shipped order"),
    (Delivered, Cancel(_)) â†’ Err("Cannot cancel delivered order"),
    (Cancelled(_), Cancel(_)) â†’ Err("Order already cancelled"),

    // Invalid transitions
    (state, event) â†’ Err("Invalid transition from " ++ show(state) ++ " on " ++ show(event))
  }
}

// Query state properties
Æ’ can_cancel(state: OrderState) â†’ ð”¹ {
  match state {
    Created â†’ true,
    PaymentPending â†’ true,
    PaymentReceived(_) â†’ true,
    Processing â†’ false,
    Shipped(_) â†’ false,
    Delivered â†’ false,
    Cancelled(_) â†’ false
  }
}

Æ’ is_terminal(state: OrderState) â†’ ð”¹ {
  match state {
    Delivered â†’ true,
    Cancelled(_) â†’ true,
    _ â†’ false
  }
}

Æ’ get_tracking(state: OrderState) â†’ Option[TrackingInfo] {
  match state {
    Shipped(info) â†’ Some(info),
    _ â†’ None
  }
}

// Order entity
rec Order {
  id: ð•Š,
  state: OrderState,
  history: [(OrderEvent, OrderState)]
}

Æ’ apply_event(order: Order, event: OrderEvent) â†’ Result[Order, ð•Š] {
  let new_state = transition(order.state, event)?
  Ok(Order {
    id: order.id,
    state: new_state,
    history: order.history ++ [(event, new_state)]
  })
}

Æ’ main() â†’ IO[()] {
  let order = Order {
    id: "ORD-001",
    state: Created,
    history: []
  }

  // Process order through states
  let payment = PaymentInfo {
    amount: 99.99,
    method: "credit_card",
    transaction_id: "txn_123"
  }

  let tracking = TrackingInfo {
    carrier: "FedEx",
    tracking_number: "FX123456789",
    estimated_delivery: today() + days(3)
  }

  // Chain of events
  let result = order
    |> apply_event(SubmitPayment(payment))
    |> flat_map(Î»o â†’ apply_event(o, PaymentConfirmed))
    |> flat_map(Î»o â†’ apply_event(o, StartProcessing))
    |> flat_map(Î»o â†’ apply_event(o, Ship(tracking)))
    |> flat_map(Î»o â†’ apply_event(o, MarkDelivered))

  match result {
    Ok(final_order) â†’ {
      println("Order completed!")
      println("Final state: " ++ show(final_order.state))
      println("History: " ++ show(len(final_order.history)) ++ " events")
    },
    Err(e) â†’ println("Error: " ++ e)
  }
}
