// Effect Types
// Demonstrates: IO, Err, effect tracking, effect composition

// Pure function â€” no effects
Æ’ add(a: â„¤, b: â„¤) â†’ â„¤ {
  a + b
}

// IO effect â€” performs input/output
Æ’ greet(name: ð•Š) â†’ IO[()] {
  println("Hello, " ++ name ++ "!")
}

// Error effect â€” can fail
rec ParseError { message: ð•Š, position: â„• }

Æ’ parse_positive(s: ð•Š) â†’ Err[ParseError, â„¤{self > 0}] {
  match parse_int(s) {
    Ok(n) if n > 0 â†’ Ok(n),
    Ok(n) â†’ Err(ParseError { message: "Expected positive", position: 0 }),
    Err(e) â†’ Err(e)
  }
}

// Combined effects â€” IO + Err
rec IoError { kind: ð•Š, path: ð•Š }

Æ’ read_number_from_file(path: ð•Š) â†’ IO[Err[IoError, â„¤]] {
  let content = read_file(path)?

  match content {
    Ok(text) â†’ {
      match parse_int(text) {
        Ok(n) â†’ Ok(n),
        Err(_) â†’ Err(IoError { kind: "parse", path })
      }
    },
    Err(e) â†’ Err(IoError { kind: "read", path })
  }
}

// Effect propagation with ?
Æ’ process_config(path: ð•Š) â†’ IO[Err[ð•Š, Config]] {
  let content = read_file(path).map_err(Î»e â†’ "Read error: " ++ e.message)?
  let config = parse_config(content).map_err(Î»e â†’ "Parse error: " ++ e.message)?
  Ok(config)
}

// Keeping effects minimal â€” pure core with effectful shell
Æ’ compute_result(data: [â„¤]) â†’ â„¤ {
  // Pure computation
  data |> filter(Î»n â†’ n > 0) |> fold(0, Î»(a, b) â†’ a + b)
}

Æ’ main() â†’ IO[()] {
  // Effectful shell
  let data = load_data()
  let result = compute_result(data)  // Pure
  println("Result: " ++ str(result))
}

// Async effect (for completeness)
Æ’ fetch_data(url: ð•Š) â†’ Async[Err[HttpError, ð•Š]] {
  // ... async HTTP request
}

Æ’ fetch_all(urls: [ð•Š]) â†’ Async[Err[HttpError, [ð•Š]]] {
  urls |> map(fetch_data) |> sequence
}
