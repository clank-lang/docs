// Advanced Refinement Types
// Demonstrates: complex predicates, dependent types, proof obligations

// Basic refinements
Ï„ NonZero = â„¤{self â‰  0}
Ï„ Positive = â„¤{self > 0}
Ï„ Negative = â„¤{self < 0}
Ï„ Natural = â„¤{self â‰¥ 0}

// Bounded range
Ï„ Byte = â„•{self â‰¤ 255}
Ï„ Percentage = â„{self â‰¥ 0.0 âˆ§ self â‰¤ 100.0}

// String refinements
Ï„ NonEmptyString = ð•Š{len(self) > 0}
Ï„ ShortString = ð•Š{len(self) â‰¤ 50}
Ï„ Username = ð•Š{len(self) â‰¥ 3 âˆ§ len(self) â‰¤ 20}

// Array refinements
Ï„ NonEmpty[T] = [T]{len(self) > 0}
Ï„ Pair[T] = [T]{len(self) == 2}

// Safe head â€” cannot fail on NonEmpty
Æ’ head[T](arr: NonEmpty[T]) â†’ T {
  arr[0]
}

// Safe last
Æ’ last[T](arr: NonEmpty[T]) â†’ T {
  arr[len(arr) - 1]
}

// Division that cannot fail
Æ’ divide(n: â„¤, d: NonZero) â†’ â„¤ {
  n Ã· d
}

// Safe array access with dependent refinement
Æ’ get_at[T](arr: [T], i: â„•{i < len(arr)}) â†’ T {
  arr[i]
}

// Dependent record â€” max must be â‰¥ min
rec Range {
  min: â„¤,
  max: â„¤{self â‰¥ min}
}

// Function that returns a value within range bounds
Æ’ clamp(value: â„¤, range: Range) â†’ â„¤{self â‰¥ range.min âˆ§ self â‰¤ range.max} {
  if value < range.min {
    range.min
  } else if value > range.max {
    range.max
  } else {
    value
  }
}

// Pre/post conditions for complex contracts
Æ’ binary_search[T: Ord](arr: [T], target: T) â†’ Option[â„•{self < len(arr)}]
  pre is_sorted(arr)
  post match result {
    Some(i) â†’ arr[i] == target,
    None â†’ Â¬contains(arr, target)
  }
{
  let mut low = 0
  let mut high = len(arr)

  while low < high {
    let mid = low + (high - low) Ã· 2
    match compare(arr[mid], target) {
      Less â†’ low = mid + 1,
      Greater â†’ high = mid,
      Equal â†’ return Some(mid)
    }
  }
  None
}

// Proof by guards â€” adding runtime checks that inform the type system
Æ’ safe_sqrt(n: â„¤) â†’ Option[â„] {
  if n >= 0 {
    // Here the compiler knows n â‰¥ 0
    Some(sqrt(float(n)))
  } else {
    None
  }
}

Æ’ main() â†’ IO[()] {
  let arr: NonEmpty[â„¤] = [1, 2, 3, 4, 5]
  println("Head: " ++ str(head(arr)))
  println("Last: " ++ str(last(arr)))

  let range = Range { min: 0, max: 100 }
  println("Clamped 150: " ++ str(clamp(150, range)))
  println("Clamped -10: " ++ str(clamp(-10, range)))
}
