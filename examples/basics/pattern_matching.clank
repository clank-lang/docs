// Pattern Matching
// Demonstrates: destructuring, nested patterns, exhaustiveness

sum Option[T] {
  Some(T),
  None
}

sum Result[T, E] {
  Ok(T),
  Err(E)
}

rec Point { x: â„¤, y: â„¤ }

// Basic destructuring
Æ’ get_or_default[T](opt: Option[T], default: T) â†’ T {
  match opt {
    Some(value) â†’ value,
    None â†’ default
  }
}

// Tuple destructuring
Æ’ swap[T, U](pair: (T, U)) â†’ (U, T) {
  let (a, b) = pair
  (b, a)
}

// Record destructuring
Æ’ distance_from_origin(p: Point) â†’ â„ {
  let Point { x, y } = p
  sqrt(float(x Ã— x + y Ã— y))
}

// Nested pattern matching
Æ’ describe_option_point(opt: Option[Point]) â†’ ð•Š {
  match opt {
    Some(Point { x: 0, y: 0 }) â†’ "origin",
    Some(Point { x: 0, y }) â†’ "on y-axis at " ++ str(y),
    Some(Point { x, y: 0 }) â†’ "on x-axis at " ++ str(x),
    Some(Point { x, y }) â†’ "at (" ++ str(x) ++ ", " ++ str(y) ++ ")",
    None â†’ "no point"
  }
}

// Pattern matching on Result
Æ’ handle_result(r: Result[â„¤, ð•Š]) â†’ ð•Š {
  match r {
    Ok(n) if n > 0 â†’ "positive: " ++ str(n),
    Ok(n) if n < 0 â†’ "negative: " ++ str(n),
    Ok(0) â†’ "zero",
    Err(msg) â†’ "error: " ++ msg
  }
}

// Range patterns
Æ’ grade(score: â„•) â†’ ð•Š {
  match score {
    90..=100 â†’ "A",
    80..90 â†’ "B",
    70..80 â†’ "C",
    60..70 â†’ "D",
    _ â†’ "F"
  }
}

Æ’ main() â†’ IO[()] {
  let p = Point { x: 3, y: 4 }
  println("Distance: " ++ str(distance_from_origin(p)))
  println(describe_option_point(Some(p)))
  println(grade(85))
}
